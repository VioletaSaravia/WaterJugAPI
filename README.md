# WaterJugAPI

WaterJugAPI is a microservice designed to solve the classic water jug problem. It provides a single POST endpoint that
takes in the capacities of two jugs and a target volume, returning the steps to achieve the target volume using the two
jugs.

## Installation

1. Install the prerequisites:

- [.NET 8 SDK](https://dotnet.microsoft.com/download/dotnet/8.0)

2. Clone the repository:
   ```sh
   git clone https://github.com/VioletaSaravia/WaterJugAPI.git
   cd WaterJugAPI
   ```

3. Build the project:

    ```sh
    dotnet build
    ```

4. Run the project:

    ```sh
    dotnet run --project WaterJugAPI
    ```

## Usage

To use the API, send a POST request to the /solve endpoint with the capacities of the two jugs and the target volume.

### POST /api/WaterJug/solve

- Content-Type: application/json
- Body Parameters:
    - x_capacity (integer): Capacity of the first jug
    - y_capacity (integer): Capacity of the second jug
    - z_amount_wanted (integer): Target volume

### Example Request

  ```json
  {
  "x_capacity": 3,
  "y_capacity": 5,
  "z_amount_wanted": 4
}
```

## Implementation

### Algorithm
The problem is solved by taking all the posible steps that can be taken from a given position, storing each one and running through all of them until one is found that matches the desired result. A breadth-first search algorithm is used to explore all possible states of the jugs. A queue keeps track of states to explore, and the "visited" array ensures no state is checked twice. A dictionary "steps" stores the sequence of actions leading to each state. For each state (amount of water in both jugs), possible next states are generated by performing each of the defined actions (filling, emptying, pouring). These next states are enqueued if they have not been visited before.

Once the target amount z is found in either jug, the method FormatSteps reconstructs the sequence of actions from the initial state to the target state. The solution steps are cached in a shared static dictionary and returned.

### Optimizations

### Algorithmic optimizations

Before running the BFS algorithm, three checks are performed:

1. `Z == 0` is checked. If true, the result of the algorithm is its initial state.
2. `z % Gcd(x, y) != 0` is checked. A helper method Gcd computes the greatest common divisor of two numbers, which is used to check if the problem has a solution. The problem can be solved only if z is a multiple of the GCD of x and y, since one can only end up with quantities of water that are multiples of `gcd(x, y)`, no matter how many operations are performed. Therefore `z % gcd(x, y)` must be 0.
3. `z > Math.Max(x, y)` is checked. The water jug problem for an input `x, y, z` cannot be solved if z is larger than both x and y.

### Caching
The class WaterJugSolver contains a static shared dictionary of previous results. If a query has been made previously, it's found as a dictionary key and the result returned immediately.

#### Memory optimizations
The actions in each step are stored as enums, then translated from enums to strings using the ToString method. This allows for 1) each step to be stored as a Value and not a reference, and 2) avoids having to allocate a string for each one. This also allows storing the next possible steps of every state in a stack-allocated Span<(int, int, enum)>, further eliminating the need for a heap allocation.

